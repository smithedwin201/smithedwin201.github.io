<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git用法]]></title>
    <url>%2F2018%2F06%2F24%2Fgit%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在一个地方好记些，不然时间一长习惯于依赖自动化工具就把命令什么的给忘了 1.注册，去掉引号就是查询当前状态git config –global user.name “tony”git config –global user.email “tony@gmail.com“ 2.基本命令git initgit add .git reset . 取消添加git commit -m “first” git statusgit diff 可以看到具体修改git checkout 回滚没有添加的修改 git loggit log -1 -p 查看一条记录的(-1)详细信息(-p) 3.用.gitignore文件建立忽略4.分支和远程仓库git branch v1 创建分支v1git checkout v1 切换分支到v1git merge v1 将v1分支和当前分支合并git branch -D v1 删除v1 设https 为远程地址 git clone httpsgit push https master 同步到远程仓库master 分支git fetch https master 远程master 拉到本地隐藏分支（用git branch -a查看）git diff &lt;隐藏分支名&gt; 查看远程和本地的不同git pull https master 下载远程并合并到本地]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散数学其他]]></title>
    <url>%2F2018%2F06%2F24%2F%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[挑一些除了图和树之外的我认为比较重要的东西总结下 二元关系 等价： 自反，对称，传递 拟序关系：反自反，反对称，传递 （大于小于） 偏序关系： 自反，反对称，传递 （大于等于小于等于） 全序关系：偏序关系中每一个元素都能比大小，也叫线序关系 良序关系：偏序集中非空子集有最小元 有限全序集一定是良序集 代数系统 幺元：ae=ea=a ——-乘了相当于没乘 零元：ae=ea=e ——-像零一样把被乘数乘没了 逆元：ab=ba=e ——-e为幺元，逆元为自身 同态：f(a*b)=f(a).f(b) 则f为同态映射 同构：当同态映射为双射时成为同构映射 群 半群： 二元运算满足结合律 群： 可逆含幺半群 封闭性 结合律 存在幺元 每个元的逆元存在 偏序格]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散数学特殊图]]></title>
    <url>%2F2018%2F06%2F24%2F%E7%89%B9%E6%AE%8A%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[特殊图 欧拉图:边不重复——连通且有零个或两个奇度数点 中国邮政问题:要走完全部边,使权和最小(欧拉图就是欧拉回路,不是就要加平行边) 可行方案:消除奇度数节点 最佳方案: 每条边的重数要小于等于2 每个基本回路上平行边的总权值不大于回路权值的一半 哈密顿图:节点不重复 巡回售货员问题:遍历所有节点,使得边权和最小 最邻近算法(没啥用):找最小的下一步走法 抄近路算法: 求最小生成树 将各边加一条与原边权值相同的平行边,所得图为欧拉图 在欧拉回路中选一个节点,按照欧拉回路的顺序访问节点,但是一旦出现重复的节点,就跳过他走到下一个节点,结果记为W(H) 如果原图满足三角不等式,d0为最小哈密顿回路的长度,则W(H)&lt;2d0 证明:设T为最小生成树,E为每条边加过平行边后的欧拉回路,H为抄近路算法求出的哈密顿回路.由三角不等式有 W(H)&lt;=W(E)=2W(T) , 最短哈密顿回路去掉任意边后就产生了一棵生成树T’,就有W(T)&lt;=W(T’)&lt;d0,就有W(H)&lt;2d0. 偶图:把节点分成两个节点集,任意边的两个端点在两个节点集中 完全偶图:两个节点集中的每个节点都有且只有一条边相关联 判定:充分必要条件是所有回路的长度均为偶数 完全匹配也叫匹配:存在V1到V2的单射 平面图 边不交叉 欧拉公式:n个节点,m条边,r个面有 n-m+r=2 判定(斯拉托夫斯基定理):图是非平面图的充要条件是它存在一个能收缩为K5或者K3,3的子图 K5,K3,3]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散数学图论]]></title>
    <url>%2F2018%2F06%2F24%2F%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%9B%BE%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[《离散数学及其应用第二版》 图论 e1=&lt;v1,v2&gt; 有向 ，e1=(v1,v2) 无向 分类 无向图，有向图，混合图 多重图：含有平行边 线图：不含平行边 简单图：无环的线图 零图：只有孤立节点 平凡图：仅含一个节点的零图 n阶图：含有n个节点 赋权图和无权图 图的操作 删除：G-e 删除节点或边 收缩：设e为边，G\e 删除e ，将e的两个端点删除并用一个新的节点替代，并保留其他关联关系 加新边：G∪（u，v）在u,v之间加一新边 子图 生成子图：节点数不变，边数小于等于原图 导出子图： 删除部分节点，后得到的子图 度和握手定理 握手定理：图中节点度数的和为边数的两倍（出度入度各一次，出度和=入度和=边数） 图中度数为奇数的节点个数为偶数个（总度数为偶数，偶度数节点和为偶数，奇度数节点和也要是偶数） 通路回路和连接性 简单通路：通路中的所有边不相同（欧拉图有关） 基本通路：通路中的所有节点互不相同（哈密顿图有关） 通路矩阵（我为了好记随便起的名):本质上是m次邻接矩阵,因为有通路就有aik=1,akj=1,即aikakj=1 aijm表示从节点vi到节点uj长度为m的通路数目 整个矩阵各元素求和为图G中长度为m的通路（包括回路）的总数目 aiim为节点vi到自身的长度为m的回路数目 在一个具有n个节点的图中，如果有通路，则最少存在一条长度不大于n-1的基本通路(无环长度为n-1,有环删环),若是说基本回路则是长度为n 可达性矩阵：将邻接矩阵做布尔积运算得到A1~An再取并集得到 无向图连通 连通图：无向图中的任何两个节点都是可达的 删除点后连通分支数变多——点割集，删除边后连通分支变多——边割集或割集 桥：若割集中只有一条边 点割集中最少的点数k叫做点连通度，也叫连通度，k-连通图，边叫k-边 完全图Kn的点连通度为 n-1(n&gt;=1),非连通图的点连通度为0 点连通度&lt;=边连通度&lt;=节点的最小的度 有向图连通 弱连通：有向转无向后连通 单向连通： 任何一对节点中，有一个能到另一个 强连通： 任何一对节点中，互相能到 有向图连通性质 强连通图判定：图中存在一条经过所有节点的回路 单向连通图判定：图中存在一条经过所有节点的通路 证明常用方法：极大基本通路法（找最大的基本通路） 连通分支 每一个节点位于且仅位于一个强（弱）连通分支中 每一个节点至少位于一个单向连通分支中 也就是说对于一个节点强联通一次，弱连通一次，单向连通若干次 无向赋权图 最短通路算法 dijkstra算法走一步看一步,求之前路径的权重和 floy算法 构建长度矩阵（值为赋权图的邻值） dijk=min{dijk-1,dikk-1+dkjk-1}表示从节点vi到vj而中间节点仅属于v1到vk的所有通路中最短通路长度(三角方式找最小权) 构建出Dn，就是最短通路长度矩阵]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语作文笔记]]></title>
    <url>%2F2018%2F06%2F24%2F%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87%E7%B4%A0%E6%9D%90%2F</url>
    <content type="text"><![CDATA[英语作文笔记 常用替换 before=prior to important=vitally matter=essential= A host of=a lot of It’s indisputable that …=There is no doubt that … 常用短语 be armed with enrich our knowledge reserves 常用句型 Just as the remark goes,” … “ 开头句式 With the rapid development of society, … When pinched between A or B, many people find themselves in a dilemma. 过渡连接 On the one hand, from the standpoint of an nation, …..On the other hand, from the perspective of individuals, … First and foremost,… 结尾句式 All we need is our utmost effort to do something … As mentioned above, …]]></content>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散数学树]]></title>
    <url>%2F2018%2F06%2F24%2F%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%A0%91%20%2F</url>
    <content type="text"><![CDATA[树 平凡树：就是平凡图 森林：连通分支都是树的无向图 树的判定（m为边数，n为节点数） 连通而不含回路 连通或不含回路，且m=n-1 无回路，但任意两节点之间加一条新边，有唯一的一条基本回路 连通，但删除任意边后，就不连通（n&gt;=2） 每队节点之间有唯一的一条基本通路 任意非平凡树都至少有两片叶(可用握手定理,m=n-1和不等式证明) 生成树:图G的生成子图是树,则称之为图G的生成树 树枝:生成树的边 弦:图G中不在生成树中的边 补:生成树所有弦的集合 生成树的判定:充分必要条件是原图是连通的(下面的俩个方法没什么用) 破圈法:删除回路中的边,直到剩下n-1条边 避圈法:选取不构成回路的边 求生成树的广度优先算法 先随便选一个节点,找与他相邻的节点做标记 最后保证每一个节点都有其前驱节点 不同的选择会有不同的生成树 最小生成树 最小生成树:对于连通赋权图,要使最后的生成树权和最小 kruskal算法: 一共取n-1条边 每次取不构成回路的最小权边 Prim算法:(每一步一定是树,不需要验证是否有回路) 取一个节点 在剩下的节点中找与已取节点邻接的最小权边 直到取完所有节点 根树:非平凡有向树,且有一个节点入度为0,其他节点入度为1 分支点:内点和根的统称 层数:从根到任意节点的通路长度 k元完全树:每个分支点恰好有k个儿子(而不是有k个节点) 若叶为t,分支数为i则:(k-1)*i=t-1 证明: t+i-1=m=k(出度为边数) 二元完全树中: i=t-1 m=n-1=i+t-1=2t-2 根树变成二叉树: 保留每个父亲和最左边儿子的连线,其他删掉 从左向右连线,即弟弟变右儿子 反过来就是右儿子变弟弟 森林变二叉树: 先把每个树变成二叉树(会导致所有二叉树的根没有右子树) 除第一个二叉树,把每个剩下的树作为作为左边树的右子树 树的权:为每一层中叶的权值*叶所在的层数之和 最优树:树的权最小 赫夫曼算法:可以解决最小前缀码和分硬币等问题 建立集合存放权值(字母出现的概率等) 取出两个最小的权值,得到其父亲v 把v加入原集合重复操作,直到集合中只有一个元素 决策树:每个分支点都是一个问题 5硬币问题:有一个硬币和其他重量不同用天平需要称几下,三下 推理从根到叶 博弈树:7根火柴问题:甲乙依次取一根或两根火柴,但不能不取,取走最后一根的人胜利 胜利的关键在于把3的倍数个火柴留给对方取 这样无论对方取一根还是两根你都可以再次把3的倍数的火柴给对方 当最后剩下3根时,对方只能去一根或者两根你就赢了 此树要从叶向根推理 关键道路法,用于合理安排工期:规则是作业&lt;v5,v6&gt;表示的作业要在&lt;s,v3&gt;,&lt;v3,v5&gt;,&lt;s,v5&gt;三个作业完成之后才能开始,求出从s到t的最低限度时间,也叫关键道路(第一个生成树) 为了不耽误整个工程的总体完成时间,并且对于非关键作业保证其机动性,有两个问题我们最为关心: 作业&lt;Vm,Vn&gt;最早什么时候能开始 计算从s到各点的最长道路.权值和就是作业最早开始时间 1. ### 作业&lt;Vm,Vn&gt;最晚什么时候必须结束 1. 计算从各节点到t的最长道路.项目整体完成时间-各节点权值和就是最晚结束时间 1. 各作业的机动时间计算方法:设作业为&lt;Vn,Vm&gt;,节点Vm的最晚结束时间-节点Vn的最早开始时间(也就是作业的最早开始时间)加上作业所需的时间,这么算的原因是任务可能不在关键道路中,在关键道路中的节点可以直接用末节点的两个时间相减]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
</search>
